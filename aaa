local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CollectionService = game:GetService("CollectionService")
local LocalPlayer = Players.LocalPlayer

-- AutoClicker Variables  
local ClickCount = 0
_G.autoclick = false

-- Rhythm AutoClicker Configuration
local RhythmAutoClicker = {
    enabled = false,
    bpm = 120,
    beatPattern = {1, 0, 1, 0}, -- 1 = click, 0 = pause
    patternIndex = 1,
    lastBeatTime = 0
}

-- Function to check if player is properly in-game
local function isPlayerInGame()
    local player = game:GetService("Players").LocalPlayer
    return player and 
           player.Character and 
           player.Character:FindFirstChild("HumanoidRootPart") and
           game:GetService("UserInputService").WindowFocused
end

-- Initialize mouse properly (critical for cursor-free clicking!)
local LocalPlayer = game:GetService("Players").LocalPlayer
local PlayerMouse = LocalPlayer:GetMouse()

-- Universal click function that works in most scenarios
local function performClick()
    if not isPlayerInGame() then return false end
    
    local success = false
    
    pcall(function()
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character
        
        -- Method 1: Tool activation (works without cursor)
        local tool = character and character:FindFirstChildOfClass("Tool")
        if tool then
            tool:Activate()
            ClickCount += 1
            success = true
            return
        end
        
        -- Method 2: Enhanced mouse1click with proper mouse initialization
        -- This should work better with cursor off-screen
        PlayerMouse = player:GetMouse() -- Re-initialize mouse
        mouse1click()
        ClickCount += 1
        success = true
    end)
    
    return success
end

-- Remote Event Spy AutoClicker (EVENT DETECTION!)
local EventSpyClicker = {
    enabled = false,
    statistics = {
        totalClicks = 0,
        sessionTime = 0,
        averageCPS = 0
    },
    clickDelay = 0.5, -- Jo≈° sporije - 2 napada po sekundi
    sessionStartTime = 0,
    detectedEvents = {},
    selectedEvent = nil,
    hookActive = false,
    lastEventTime = 0,
    cooldownPeriod = 0.5, -- Minimum 0.5s izmeƒëu eventa
    rateLimitCounter = 0,
    maxEventsPerSecond = 2,
    currentCombo = 1, -- Combo counter 1-5
    maxCombo = 5, -- Maximum combo hits
    comboData = {
        [1] = { animation = "Punch1", isDash = false }, -- Fixed to Punch1 for air attacks
        [2] = { animation = "Punch2", isDash = false },
        [3] = { animation = "Punch3", isDash = false },
        [4] = { animation = "GroundPunch4", isDash = false },
        [5] = { animation = "GroundPunch5", isDash = false }
    },
    comboPunchDelay = 0.3 -- Editable delay between individual punches in combo
}

-- Remote Event Spy Functions
function EventSpyClicker:startEventSpy()
    if self.hookActive then return end
    
    print("üîç Starting Remote Event Spy...")
    self.detectedEvents = {}
    
    local success, error = pcall(function()
        if hookmetamethod then
            local originalNamecall = nil
            originalNamecall = hookmetamethod(game, "__namecall", function(remote, ...)
                local args = {...}
                local method = getnamecallmethod()
                
                if method == "FireServer" and remote:IsA("RemoteEvent") then
                    -- Log the remote event
                    local eventData = {
                        name = remote.Name,
                        fullName = remote:GetFullName(),
                        args = args,
                        time = tick()
                    }
                    
                    -- Store unique events
                    local eventKey = remote.Name .. "_" .. remote:GetFullName()
                    if not self.detectedEvents[eventKey] then
                        self.detectedEvents[eventKey] = eventData
                        print("üéØ Detected RemoteEvent:", remote.Name, "at", remote:GetFullName())
                        print("   Args:", unpack(args))
                    end
                end
                
                return originalNamecall(remote, ...)
            end)
            
            self.hookActive = true
            print("‚úÖ Remote Event Spy is now active!")
            print("üéÆ Perform a melee attack in-game to detect the event!")
        else
            error("hookmetamethod not supported by executor")
        end
    end)
    
    if not success then
        print("‚ùå Failed to start Remote Event Spy:", error)
    end
end

function EventSpyClicker:listDetectedEvents()
    print("üìã Detected Remote Events:")
    local count = 0
    for key, event in pairs(self.detectedEvents) do
        count = count + 1
        print(string.format("  %d. %s (%s)", count, event.name, event.fullName))
    end
    if count == 0 then
        print("   No events detected yet. Try attacking or interacting in-game!")
    end
end

function EventSpyClicker:selectEvent(eventName)
    for key, event in pairs(self.detectedEvents) do
        if event.name == eventName then
            self.selectedEvent = event
            print("‚úÖ Selected event:", eventName)
            return true
        end
    end
    print("‚ùå Event not found:", eventName)
    return false
end

function EventSpyClicker:canFireEvent()
    local currentTime = tick()
    
    -- Check cooldown period
    if currentTime - self.lastEventTime < self.cooldownPeriod then
        return false, "Cooldown active"
    end
    
    -- Check rate limiting (events per second)
    local timeSinceLastReset = currentTime - (self.lastRateLimitReset or 0)
    if timeSinceLastReset >= 1.0 then
        -- Reset counter every second
        self.rateLimitCounter = 0
        self.lastRateLimitReset = currentTime
    end
    
    if self.rateLimitCounter >= self.maxEventsPerSecond then
        return false, "Rate limit exceeded"
    end
    
    return true, "OK"
end

function EventSpyClicker:getNextComboHit()
    local comboHit = self.currentCombo
    local comboInfo = self.comboData[comboHit]
    local animationName = comboInfo.animation
    local isDash = comboInfo.isDash
    
    -- Advance to next combo hit
    self.currentCombo = self.currentCombo + 1
    if self.currentCombo > self.maxCombo then
        self.currentCombo = 1 -- Reset combo back to 1
    end
    
    return comboHit, animationName, isDash
end

function EventSpyClicker:fireCombatEvent()
    local canFire, reason = self:canFireEvent()
    
    if not canFire then
        print("‚è≥ Event blocked:", reason)
        return false
    end
    
    pcall(function()
        -- Get next combo hit with exact parameters from your Cobalt trace
        local comboHit, animationName, isDash = self:getNextComboHit()
        
        -- USE YOUR EXACT COBALT-TRACED COMBAT EVENT!
        local Event = game:GetService("ReplicatedStorage").Events.CombatRegister
        Event:InvokeServer(
            {
                "swingsfx",
                "Melee",
                comboHit, -- 1, 2, 3, 4, 5, 1, 2, 3...
                "Ground",
                isDash, -- true for combo 1 (Dash), false for others
                game:GetService("ReplicatedStorage").CombatAnimations.Melee[animationName], -- Dash, Punch2, Punch3, GroundPunch4, GroundPunch5
                2,
                2
            }
        )
        
        -- Update rate limiting
        self.lastEventTime = tick()
        self.rateLimitCounter = self.rateLimitCounter + 1
        
        self.statistics.totalClicks = self.statistics.totalClicks + 1
        ClickCount += 1
        print("ü•ä Fired CombatRegister combo", comboHit, "(" .. animationName .. ", isDash:", isDash, ")")
    end)
    
    return true
end

function EventSpyClicker:isPlayerReady()
    local player = LocalPlayer
    return player and 
           player.Character and 
           player.Character:FindFirstChild("HumanoidRootPart") and
           player.Character:FindFirstChild("Humanoid") and
           player.Character.Humanoid.Health > 0
end

function EventSpyClicker:start()
    self.enabled = true
    self.sessionStartTime = tick()
    
    print("üöÄ Starting AutoClicker with CombatRegister combo sequence!")
    
    -- Start the clicking loop with YOUR COMBAT EVENT!
    spawn(function()
        while self.enabled do
            if self:isPlayerReady() then
                -- USE YOUR DISCOVERED COMBAT EVENT!
                self:fireCombatEvent()
                
                -- Use combo punch delay for individual punches
                local baseDelay = self.comboPunchDelay
                local variation = math.random(85, 115) / 100  -- ¬±15% variation
                local finalDelay = baseDelay * variation
                
                -- Occasional longer pause between combos (3% chance)
                if math.random() < 0.03 then
                    finalDelay = finalDelay + math.random(0.1, 0.5)
                end
                
                wait(finalDelay)
            else
                wait(1)
            end
        end
    end)
end

function EventSpyClicker:stop()
    self.enabled = false
    
    -- Update statistics
    if self.sessionStartTime then
        self.statistics.sessionTime = tick() - self.sessionStartTime
        if self.statistics.sessionTime > 0 then
            self.statistics.averageCPS = self.statistics.totalClicks / self.statistics.sessionTime
        end
    end
end

local function toggleAutoClicker(enabled)
    if enabled then
        EventSpyClicker:start()
    else
        EventSpyClicker:stop()
    end
end

-- Speed Hack Variables
local SpeedHackEnabled = false
local SpeedValue = 50
local SpeedConnection = nil

-- Fly Mode Variables
local FlyEnabled = false
local FlySpeed = 50
local FlyConnection = nil
local FlyBodyGyro = nil
local FlyBodyVelocity = nil

-- Store speed hack state before flying
local WasSpeedHackEnabled = false

-- Speed Hack Functions
local function enableSpeedHack()
    if SpeedConnection then
        SpeedConnection:Disconnect()
        SpeedConnection = nil
    end
    
    SpeedConnection = RunService.Heartbeat:Connect(function()
        if SpeedHackEnabled and not FlyEnabled then
            local character = LocalPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                local rootPart = character.HumanoidRootPart
                
                for _, obj in pairs(rootPart:GetChildren()) do
                    if obj.Name == "SpeedBody" then
                        obj:Destroy()
                    end
                end
                
                local bodyVelocity = Instance.new("BodyVelocity")
                bodyVelocity.Name = "SpeedBody"
                bodyVelocity.MaxForce = Vector3.new(100000, 0, 100000)
                bodyVelocity.P = 20000
                CollectionService:AddTag(bodyVelocity, "AllowedBM")
                bodyVelocity.Parent = rootPart
                
                local moveVector = Vector3.new(0, 0, 0)
                local camera = workspace.CurrentCamera
                
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                    moveVector = moveVector + camera.CFrame.LookVector
                elseif UserInputService:IsKeyDown(Enum.KeyCode.S) then
                    moveVector = moveVector - camera.CFrame.LookVector
                end
                
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                    moveVector = moveVector - camera.CFrame.RightVector
                elseif UserInputService:IsKeyDown(Enum.KeyCode.D) then
                    moveVector = moveVector + camera.CFrame.RightVector
                end
                
                if moveVector.Magnitude > 0 then
                    bodyVelocity.Velocity = Vector3.new(moveVector.Unit.X, rootPart.Velocity.Y, moveVector.Unit.Z) * SpeedValue
                else
                    bodyVelocity.Velocity = Vector3.new(0, rootPart.Velocity.Y, 0)
                end
                
                task.delay(0.05, function()
                    if bodyVelocity and bodyVelocity.Parent then
                        bodyVelocity:Destroy()
                    end
                end)
            end
        end
    end)
end

local function disableSpeedHack()
    if SpeedConnection then
        SpeedConnection:Disconnect()
        SpeedConnection = nil
    end
    
    local character = LocalPlayer.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local rootPart = character.HumanoidRootPart
        for _, obj in pairs(rootPart:GetChildren()) do
            if obj.Name == "SpeedBody" then
                obj:Destroy()
            end
        end
    end
end

local function toggleSpeedHack(enabled)
    if FlyEnabled and enabled then
        if Options and Options.SpeedToggle then
            Options.SpeedToggle:SetValue(false)
        end
        return
    end
    
    SpeedHackEnabled = enabled
    if enabled then
        enableSpeedHack()
    else
        disableSpeedHack()
    end
end

-- Fly Mode Functions
local function enableFly()
    if FlyConnection then
        FlyConnection:Disconnect()
        FlyConnection = nil
    end
    
    WasSpeedHackEnabled = SpeedHackEnabled
    if SpeedHackEnabled then
        toggleSpeedHack(false)
    end
    
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    local rootPart = character.HumanoidRootPart
    
    for _, obj in pairs(rootPart:GetChildren()) do
        if obj.Name == "FlyGyro" or obj.Name == "FlyVelocity" then
            obj:Destroy()
        end
    end
    
    FlyBodyGyro = Instance.new("BodyGyro")
    FlyBodyGyro.Name = "FlyGyro"
    FlyBodyGyro.P = 100000
    FlyBodyGyro.MaxTorque = Vector3.new(100000, 100000, 100000)
    FlyBodyGyro.CFrame = rootPart.CFrame
    CollectionService:AddTag(FlyBodyGyro, "AllowedBM")
    FlyBodyGyro.Parent = rootPart
    
    FlyBodyVelocity = Instance.new("BodyVelocity")
    FlyBodyVelocity.Name = "FlyVelocity"
    FlyBodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
    FlyBodyVelocity.P = 100000
    FlyBodyVelocity.Velocity = Vector3.new(0, 0, 0)
    CollectionService:AddTag(FlyBodyVelocity, "AllowedBM")
    FlyBodyVelocity.Parent = rootPart
    
    FlyConnection = RunService.Heartbeat:Connect(function()
        if FlyEnabled and character and character:FindFirstChild("HumanoidRootPart") then
            local moveVector = Vector3.new(0, 0, 0)
            local camera = workspace.CurrentCamera
            
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                moveVector = moveVector + camera.CFrame.LookVector
            elseif UserInputService:IsKeyDown(Enum.KeyCode.S) then
                moveVector = moveVector - camera.CFrame.LookVector
            end
            
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                moveVector = moveVector - camera.CFrame.RightVector
            elseif UserInputService:IsKeyDown(Enum.KeyCode.D) then
                moveVector = moveVector + camera.CFrame.RightVector
            end
            
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                moveVector = moveVector + Vector3.new(0, 1, 0)
            elseif UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.RightShift) then
                moveVector = moveVector + Vector3.new(0, -1, 0)
            end
            
            FlyBodyGyro.CFrame = camera.CFrame
            
            if moveVector.Magnitude > 0 then
                FlyBodyVelocity.Velocity = moveVector.Unit * FlySpeed
            else
                FlyBodyVelocity.Velocity = Vector3.new(0, 0, 0)
            end
        end
    end)
end

local function disableFly()
    if FlyConnection then
        FlyConnection:Disconnect()
        FlyConnection = nil
    end
    if FlyBodyGyro then
        FlyBodyGyro:Destroy()
        FlyBodyGyro = nil
    end
    if FlyBodyVelocity then
        FlyBodyVelocity:Destroy()
        FlyBodyVelocity = nil
    end
    
    local character = LocalPlayer.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local rootPart = character.HumanoidRootPart
        for _, obj in pairs(rootPart:GetChildren()) do
            if obj.Name == "FlyGyro" or obj.Name == "FlyVelocity" then
                obj:Destroy()
            end
        end
    end
    
    if character and character:FindFirstChild("HumanoidRootPart") then
        character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
    end
    
    if WasSpeedHackEnabled then
        task.wait(0.1)
        toggleSpeedHack(true)
        if Options and Options.SpeedToggle then
            Options.SpeedToggle:SetValue(true)
        end
    end
end

local function toggleFly(enabled)
    FlyEnabled = enabled
    if enabled then
        enableFly()
    else
        disableFly()
    end
end

-- Set up T key toggle for fly mode
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.KeyCode == Enum.KeyCode.T then
        local newState = not FlyEnabled
        toggleFly(newState)
        
        if Options and Options.FlyToggle then
            Options.FlyToggle:SetValue(newState)
        end
    end
end)

-- Improved Player ESP with Health
local ESPEnabled = false
local ShowBoxes = true
local ShowNames = true
local ShowDistance = true
local ShowHealth = true
local TeamCheck = true
local ESPObjects = {}

local function CreateESP(player)
    if player == LocalPlayer then return end
    
    local function AddESP(character)
        if not character or not character:FindFirstChild("HumanoidRootPart") then return end
        
        local esp = {
            Player = player,
            Character = character,
            Components = {}
        }
        
        -- Box
        esp.Components.Box = Drawing.new("Square")
        esp.Components.Box.Visible = false
        esp.Components.Box.Color = Color3.fromRGB(255, 255, 255)
        esp.Components.Box.Thickness = 2
        esp.Components.Box.Filled = false
        
        -- Name
        esp.Components.Name = Drawing.new("Text")
        esp.Components.Name.Visible = false
        esp.Components.Name.Color = Color3.fromRGB(255, 255, 255)
        esp.Components.Name.Size = 16
        esp.Components.Name.Center = true
        esp.Components.Name.Outline = true
        
        -- Distance
        esp.Components.Distance = Drawing.new("Text")
        esp.Components.Distance.Visible = false
        esp.Components.Distance.Color = Color3.fromRGB(27, 209, 179)
        esp.Components.Distance.Size = 14
        esp.Components.Distance.Center = true
        esp.Components.Distance.Outline = true
        
        -- Health
        esp.Components.Health = Drawing.new("Text")
        esp.Components.Health.Visible = false
        esp.Components.Health.Color = Color3.fromRGB(0, 255, 0)
        esp.Components.Health.Size = 14
        esp.Components.Health.Center = true
        esp.Components.Health.Outline = true
        
        ESPObjects[player] = esp
    end
    
    if player.Character then
        AddESP(player.Character)
    end
    
    player.CharacterAdded:Connect(AddESP)
    player.CharacterRemoving:Connect(function()
        if ESPObjects[player] then
            for _, component in pairs(ESPObjects[player].Components) do
                component:Remove()
            end
            ESPObjects[player] = nil
        end
    end)
end

local function UpdateESP()
    for player, esp in pairs(ESPObjects) do
        if not esp.Character or not esp.Character.Parent or not esp.Character:FindFirstChild("HumanoidRootPart") then
            for _, component in pairs(esp.Components) do
                component.Visible = false
            end
            continue
        end
        
        local rootPart = esp.Character.HumanoidRootPart
        local humanoid = esp.Character:FindFirstChildOfClass("Humanoid")
        
        if not rootPart or not humanoid then continue end
        
        local position, onScreen = workspace.CurrentCamera:WorldToViewportPoint(rootPart.Position)
        
        if onScreen then
            local distance = (LocalPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude
            local scale = 1 / (position.Z * math.tan(math.rad(workspace.CurrentCamera.FieldOfView * 0.5)) * 2) * 100
            local size = Vector2.new(4 * scale, 6 * scale)
            
            -- Box
            if ShowBoxes then
                esp.Components.Box.Size = size
                esp.Components.Box.Position = Vector2.new(position.X - size.X / 2, position.Y - size.Y / 2)
                esp.Components.Box.Visible = ESPEnabled
                esp.Components.Box.Color = (TeamCheck and player.Team == LocalPlayer.Team) and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
            else
                esp.Components.Box.Visible = false
            end
            
            -- Name, Distance and Health
            local textOffset = 0
            
            if ShowNames then
                esp.Components.Name.Text = player.Name
                esp.Components.Name.Position = Vector2.new(position.X, position.Y - size.Y / 2 - 20 - textOffset)
                esp.Components.Name.Visible = ESPEnabled
                esp.Components.Name.Color = esp.Components.Box.Color
                textOffset = textOffset + 20
            else
                esp.Components.Name.Visible = false
            end
            
            if ShowDistance then
                esp.Components.Distance.Text = math.floor(distance) .. " studs"
                esp.Components.Distance.Position = Vector2.new(position.X, position.Y - size.Y / 2 - 20 - textOffset)
                esp.Components.Distance.Visible = ESPEnabled
                textOffset = textOffset + 20
            else
                esp.Components.Distance.Visible = false
            end
            
            if ShowHealth and humanoid then
                local healthPercent = humanoid.Health / humanoid.MaxHealth
                local healthColor
                if healthPercent > 0.7 then
                    healthColor = Color3.fromRGB(0, 255, 0)
                elseif healthPercent > 0.3 then
                    healthColor = Color3.fromRGB(255, 255, 0)
                else
                    healthColor = Color3.fromRGB(255, 0, 0)
                end
                
                esp.Components.Health.Text = math.floor(humanoid.Health) .. "/" .. math.floor(humanoid.MaxHealth)
                esp.Components.Health.Position = Vector2.new(position.X, position.Y - size.Y / 2 - 20 - textOffset)
                esp.Components.Health.Visible = ESPEnabled
                esp.Components.Health.Color = healthColor
            else
                esp.Components.Health.Visible = false
            end
        else
            for _, component in pairs(esp.Components) do
                component.Visible = false
            end
        end
    end
end

local function ToggleESP(enabled)
    ESPEnabled = enabled
    
    if enabled then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                CreateESP(player)
            end
        end
        
        Players.PlayerAdded:Connect(function(player)
            CreateESP(player)
        end)
        
        RunService:BindToRenderStep("ESPUpdate", Enum.RenderPriority.Camera.Value, UpdateESP)
    else
        RunService:UnbindFromRenderStep("ESPUpdate")
        
        for player, esp in pairs(ESPObjects) do
            for _, component in pairs(esp.Components) do
                component:Remove()
            end
        end
        ESPObjects = {}
    end
end

-- FIXED Chest ESP (Drawing based - won't crash)
local ChestESPEnabled = false
local ShowLegendary = true
local ShowMythic = true
local ChestESPObjects = {}
local ChestESPRenderStep = nil

local function CreateChestESP(chestModel, chestType)
    if ChestESPObjects[chestModel] then return end
    
    local chest = {
        Model = chestModel,
        Type = chestType,
        Components = {}
    }
    
    -- Box
    chest.Components.Box = Drawing.new("Square")
    chest.Components.Box.Visible = false
    chest.Components.Box.Thickness = 2
    chest.Components.Box.Filled = false
    
    -- Text
    chest.Components.Text = Drawing.new("Text")
    chest.Components.Text.Visible = false
    chest.Components.Text.Size = 16
    chest.Components.Text.Center = true
    chest.Components.Text.Outline = true
    
    if chestType == "Legendary" then
        chest.Components.Box.Color = Color3.fromRGB(255, 215, 0) -- Gold
        chest.Components.Text.Color = Color3.fromRGB(255, 215, 0)
        chest.Components.Text.Text = "LEGENDARY CHEST"
    else
        chest.Components.Box.Color = Color3.fromRGB(148, 0, 211) -- Purple
        chest.Components.Text.Color = Color3.fromRGB(148, 0, 211)
        chest.Components.Text.Text = "MYTHIC CHEST"
    end
    
    ChestESPObjects[chestModel] = chest
    
    -- Clean up when chest is removed
    chestModel.AncestryChanged:Connect(function(_, parent)
        if parent == nil then
            if ChestESPObjects[chestModel] then
                for _, component in pairs(ChestESPObjects[chestModel].Components) do
                    component:Remove()
                end
                ChestESPObjects[chestModel] = nil
            end
        end
    end)
end

local function UpdateChestESP()
    for chestModel, chest in pairs(ChestESPObjects) do
        if not chestModel or not chestModel.Parent then
            for _, component in pairs(chest.Components) do
                component.Visible = false
                component:Remove()
            end
            ChestESPObjects[chestModel] = nil
            continue
        end
        
        local primaryPart = chestModel.PrimaryPart or chestModel:FindFirstChildOfClass("MeshPart")
        if not primaryPart then continue end
        
        local position, onScreen = workspace.CurrentCamera:WorldToViewportPoint(primaryPart.Position)
        
        if onScreen then
            local distance = (LocalPlayer.Character.HumanoidRootPart.Position - primaryPart.Position).Magnitude
            local scale = math.clamp(1 / (position.Z * 0.1), 0.5, 3)
            local size = Vector2.new(60 * scale, 40 * scale)
            
            -- Box
            chest.Components.Box.Size = size
            chest.Components.Box.Position = Vector2.new(position.X - size.X / 2, position.Y - size.Y / 2)
            chest.Components.Box.Visible = ChestESPEnabled
            
            -- Text
            chest.Components.Text.Position = Vector2.new(position.X, position.Y + size.Y / 2 + 15)
            chest.Components.Text.Visible = ChestESPEnabled
        else
            chest.Components.Box.Visible = false
            chest.Components.Text.Visible = false
        end
    end
end

local function CheckChests()
    for _, v in pairs(game:GetService("Workspace").Effects:GetChildren()) do
        if v:IsA("Model") then
            local chestPart = v:FindFirstChildOfClass("MeshPart")
            if chestPart then
                if ShowLegendary and chestPart.MeshId == "rbxassetid://10798559852" then
                    CreateChestESP(v, "Legendary")
                elseif ShowMythic and chestPart.MeshId == "rbxassetid://10811929054" then
                    CreateChestESP(v, "Mythic")
                end
            end
        end
    end
end

local function ToggleChestESP(enabled)
    ChestESPEnabled = enabled
    
    if enabled then
        -- Initial check
        CheckChests()
        
        -- Set up listeners for new chests
        local chestAddedConnection = game:GetService("Workspace").Effects.ChildAdded:Connect(function(child)
            if child:IsA("Model") then
                task.wait(0.5) -- Wait a bit for the chest to fully load
                CheckChests()
            end
        end)
        
        -- Update chests periodically
        local chestCheckConnection = RunService.Heartbeat:Connect(function()
            CheckChests()
        end)
        
        -- Start render step for drawing updates
        ChestESPRenderStep = RunService.RenderStepped:Connect(UpdateChestESP)
        
        -- Store connections for cleanup
        ChestESPObjects.Connections = {
            chestAddedConnection,
            chestCheckConnection
        }
    else
        -- Clean up everything
        if ChestESPRenderStep then
            ChestESPRenderStep:Disconnect()
            ChestESPRenderStep = nil
        end
        
        if ChestESPObjects.Connections then
            for _, connection in ipairs(ChestESPObjects.Connections) do
                connection:Disconnect()
            end
            ChestESPObjects.Connections = nil
        end
        
        for chestModel, chest in pairs(ChestESPObjects) do
            if chest.Components then
                for _, component in pairs(chest.Components) do
                    component.Visible = false
                    component:Remove()
                end
            end
        end
        ChestESPObjects = {}
    end
end

-- FIXED Medal ESP (No duplicate text)
local MedalESPEnabled = false
local MedalESPConnections = {}
local MedalHighlights = {}

local MedalColors = {
    ["DragonClaw Medal"] = Color3.fromRGB(0, 255, 0),
    ["Electro Medal"] = Color3.fromRGB(0, 127, 255),
    ["Fishman Karate Medal"] = Color3.fromRGB(0, 0, 156),
    ["Rokushiki Medal"] = Color3.fromRGB(107, 35, 142),
    ["BlackLeg Medal"] = Color3.fromRGB(30, 30, 30),
    ["1SS Medal"] = Color3.fromRGB(112, 147, 219),
    ["2SS Medal"] = Color3.fromRGB(47, 79, 47)
}

local function CreateMedalESP(medal, medalType)
    if MedalHighlights[medal] then return end
    
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "MedalESP"
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.Adornee = medal
    billboard.AlwaysOnTop = true
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.Enabled = MedalESPEnabled
    billboard.Parent = medal
    
    local label = Instance.new("TextLabel")
    label.Text = medalType:gsub(" Medal", "")
    label.TextColor3 = MedalColors[medalType]
    label.TextSize = 16
    label.Font = Enum.Font.GothamBold
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(1, 0, 1, 0)
    label.Parent = billboard
    
    local highlight = Instance.new("Highlight")
    highlight.Adornee = medal
    highlight.FillColor = MedalColors[medalType]
    highlight.FillTransparency = 0.5
    highlight.OutlineColor = MedalColors[medalType]
    highlight.OutlineTransparency = 0
    highlight.Enabled = MedalESPEnabled
    highlight.Parent = medal
    
    MedalHighlights[medal] = {
        Billboard = billboard,
        Highlight = highlight
    }
    
    -- Clean up when medal is removed
    medal.AncestryChanged:Connect(function(_, parent)
        if parent == nil then
            if MedalHighlights[medal] then
                MedalHighlights[medal].Billboard:Destroy()
                MedalHighlights[medal].Highlight:Destroy()
                MedalHighlights[medal] = nil
            end
        end
    end)
end

local function CheckMedals()
    for medalType, color in pairs(MedalColors) do
        local medalFolder = game:GetService("Workspace").Effects:FindFirstChild(medalType)
        if medalFolder then
            for _, medal in pairs(medalFolder:GetChildren()) do
                if medal:IsA("Part") and not MedalHighlights[medal] then
                    CreateMedalESP(medal, medalType)
                end
            end
        end
    end
end

local function UpdateMedalVisibility()
    for medal, esp in pairs(MedalHighlights) do
        if esp.Billboard and esp.Highlight then
            esp.Billboard.Enabled = MedalESPEnabled
            esp.Highlight.Enabled = MedalESPEnabled
        end
    end
end

local function ToggleMedalESP(enabled)
    MedalESPEnabled = enabled
    
    if enabled then
        -- Initial check
        CheckMedals()
        
        -- Set up listeners for each medal type
        for medalType, color in pairs(MedalColors) do
            local medalFolder = game:GetService("Workspace").Effects:FindFirstChild(medalType)
            if medalFolder then
                local connection = medalFolder.ChildAdded:Connect(function(child)
                    if child:IsA("Part") then
                        CreateMedalESP(child, medalType)
                    end
                end)
                table.insert(MedalESPConnections, connection)
            end
        end
        
        -- Periodic check
        local periodicCheck = RunService.Heartbeat:Connect(function()
            CheckMedals()
        end)
        table.insert(MedalESPConnections, periodicCheck)
        
        UpdateMedalVisibility()
    else
        -- Disconnect all connections
        for _, connection in ipairs(MedalESPConnections) do
            connection:Disconnect()
        end
        MedalESPConnections = {}
        
        -- Update visibility
        UpdateMedalVisibility()
    end
end

-- Autofarm Variables
local AutoFarmEnabled = false
local AutoFarmConnection = nil
local TweenFarmSpeed = 50

local function StartAutoFarm()
    if AutoFarmConnection then
        AutoFarmConnection:Disconnect()
    end
    
    local farmBodyVelocity = nil
    local targetNPC = nil
    local lastNPCCheck = 0
    local checkInterval = 0.1
    local currentTargetPosition = nil
    
    AutoFarmConnection = RunService.Heartbeat:Connect(function()
        if not AutoFarmEnabled or not LocalPlayer.Character then 
            if farmBodyVelocity then
                farmBodyVelocity:Destroy()
                farmBodyVelocity = nil
            end
            targetNPC = nil
            currentTargetPosition = nil
            return 
        end
        
        local character = LocalPlayer.Character
        local rootPart = character.HumanoidRootPart
        
        local currentTime = tick()
        
        if currentTime - lastNPCCheck >= checkInterval or not targetNPC or not targetNPC.Parent then
            lastNPCCheck = currentTime
            
            local nearestDistance = math.huge
            local newTargetNPC = nil
            
            for _, npc in pairs(game:GetService("Workspace").NPCs:GetChildren()) do
                if npc.Name == "Bandit" and npc:FindFirstChild("HumanoidRootPart") then
                    local distance = (rootPart.Position - npc.HumanoidRootPart.Position).Magnitude
                    if distance < nearestDistance then
                        nearestDistance = distance
                        newTargetNPC = npc
                    end
                end
            end
            
            targetNPC = newTargetNPC
            
            if targetNPC and targetNPC.Parent and targetNPC:FindFirstChild("HumanoidRootPart") then
                currentTargetPosition = targetNPC.HumanoidRootPart.Position + Vector3.new(0, 7, 0)
            else
                currentTargetPosition = nil
                targetNPC = nil
            end
        end
        
        if currentTargetPosition then
            if not farmBodyVelocity then
                farmBodyVelocity = Instance.new("BodyVelocity")
                farmBodyVelocity.Name = "FarmBody"
                farmBodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
                farmBodyVelocity.P = 20000
                CollectionService:AddTag(farmBodyVelocity, "AllowedBM")
                farmBodyVelocity.Parent = rootPart
            end
            
            local direction = (currentTargetPosition - rootPart.Position)
            local distance = direction.Magnitude
            
            -- ADD DEAD ZONE - stop moving if within 3 studs of target
            if distance < 1 then
                farmBodyVelocity.Velocity = Vector3.new(0, 0, 0)
            else
                -- Only move if we're outside the dead zone
                farmBodyVelocity.Velocity = direction.Unit * TweenFarmSpeed
            end
            
        else
            if farmBodyVelocity then
                farmBodyVelocity.Velocity = Vector3.new(0, 0, 0)
            end
        end
    end)
end

local function ToggleAutoFarm(enabled)
    AutoFarmEnabled = enabled
    
    if enabled then
        StartAutoFarm()
    else
        if AutoFarmConnection then
            AutoFarmConnection:Disconnect()
            AutoFarmConnection = nil
        end
        
        -- Clean up body velocity properly
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local rootPart = character.HumanoidRootPart
            for _, obj in pairs(rootPart:GetChildren()) do
                if obj.Name == "FarmBody" then
                    obj:Destroy()
                end
            end
        end
        
        -- Also clean up any other movement objects that might be stuck
        if character and character:FindFirstChild("Humanoid") then
            character.Humanoid.PlatformStand = false
        end
        
        -- Reset velocity
        if character and character:FindFirstChild("HumanoidRootPart") then
            character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
        end
    end
end

-- Fruit Rain
local function StartFruitRain()
    loadstring(game:HttpGet('https://raw.githubusercontent.com/acsu123/HOHO_H/SCRIPTS/gpo_rain-obfuscated.lua'))()
end

-- Create Window
local Window = Fluent:CreateWindow({
    Title = "Fluent " .. Fluent.Version,
    SubTitle = "by dawid",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

-- Create Tabs
local Tabs = {
    Combat = Window:AddTab({ Title = "Combat", Icon = "sword" }),
    Movement = Window:AddTab({ Title = "Movement", Icon = "running" }),
    PlayerESP = Window:AddTab({ Title = "Player ESP", Icon = "users" }),
    ChestESP = Window:AddTab({ Title = "Chest ESP", Icon = "treasure" }),
    MedalESP = Window:AddTab({ Title = "Medal ESP", Icon = "award" }),
    Autofarm = Window:AddTab({ Title = "Autofarm", Icon = "settings" }),
    Trolling = Window:AddTab({ Title = "Trolling", Icon = "smile" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local Options = Fluent.Options

-- Combat Tab
do
    Tabs.Combat:AddParagraph({
        Title = "CombatRegister AutoClicker",
        Content = "PERFECT! Uses your discovered CombatRegister event - NO CURSOR DEPENDENCY!"
    })

    local AutoClickerToggle = Tabs.Combat:AddToggle("AutoClickerToggle", {
        Title = "AutoClicker",
        Description = "Enable/disable CombatRegister autoclicker",
        Default = false
    })

    AutoClickerToggle:OnChanged(function()
        toggleAutoClicker(Options.AutoClickerToggle.Value)
    end)

    local ClickDelaySlider = Tabs.Combat:AddSlider("ClickDelaySlider", {
        Title = "Attack Speed (seconds)",
        Description = "Time between CombatRegister events (min 0.5s for rate limiting)",
        Default = 0.5, -- Sigurno - 2 napada po sekundi
        Min = 0.5,
        Max = 3.0,
        Rounding = 1,
        Callback = function(Value)
            EventSpyClicker.clickDelay = Value
            EventSpyClicker.cooldownPeriod = math.max(0.5, Value) -- Cooldown nikad manji od 0.5s
        end
    })

    local ComboPunchDelaySlider = Tabs.Combat:AddSlider("ComboPunchDelaySlider", {
        Title = "Combo Punch Delay (seconds)",
        Description = "Delay between individual punches in combo sequence",
        Default = 0.3,
        Min = 0.1,
        Max = 1.0,
        Rounding = 2,
        Callback = function(Value)
            EventSpyClicker.comboPunchDelay = Value
        end
    })

    Tabs.Combat:AddButton({
        Title = "Test Combat Event",
        Description = "Test single CombatRegister event",
        Callback = function()
            EventSpyClicker:fireCombatEvent()
            Fluent:Notify({
                Title = "Combat Test",
                Content = "CombatRegister event fired!",
                Duration = 3
            })
        end
    })

    -- Statistics display
    Tabs.Combat:AddParagraph({
        Title = "AutoClicker Statistics",
        Content = "Clicks: " .. ClickCount .. " | Session Time: 0s | Avg CPS: 0"
    })

    -- Reset statistics button
    Tabs.Combat:AddButton({
        Title = "Reset Statistics",
        Description = "Reset all autoclicker statistics",
        Callback = function()
            ClickCount = 0
            EventSpyClicker.statistics.totalClicks = 0
            EventSpyClicker.statistics.sessionTime = 0
            EventSpyClicker.statistics.averageCPS = 0
            Fluent:Notify({
                Title = "Remote Event Spy AutoClicker",
                Content = "Statistics have been reset",
                Duration = 3
            })
        end
    })

    -- Update statistics display periodically
    spawn(function()
        while true do
            wait(1)
            if Options then
                for _, element in pairs(Tabs.Combat.Elements) do
                    if element.Type == "Paragraph" and element.Data.Title == "AutoClicker Statistics" then
                        local sessionTime = EventSpyClicker.sessionStartTime and (tick() - EventSpyClicker.sessionStartTime) or 0
                        local avgCPS = sessionTime > 0 and (EventSpyClicker.statistics.totalClicks / sessionTime) or 0
                        
                        local content = string.format(
                            "Clicks: %d | Session Time: %ds | Avg CPS: %.1f",
                            ClickCount,
                            math.floor(sessionTime),
                            avgCPS
                        )
                        
                        element.SetContent(content)
                        break
                    end
                end
            end
        end
    end)
end

-- Movement Tab
do
    Tabs.Movement:AddParagraph({
        Title = "Speed Hack",
        Content = "Toggle and adjust speed multiplier"
    })

    local SpeedToggle = Tabs.Movement:AddToggle("SpeedToggle", {
        Title = "Speed Hack",
        Description = "Enable/disable speed hack",
        Default = false
    })

    SpeedToggle:OnChanged(function()
        toggleSpeedHack(Options.SpeedToggle.Value)
    end)

    local SpeedSlider = Tabs.Movement:AddSlider("SpeedSlider", {
        Title = "Speed Value",
        Description = "Adjust the speed multiplier",
        Default = 50,
        Min = 20,
        Max = 200,
        Rounding = 1,
        Callback = function(Value)
            SpeedValue = Value
        end
    })

    Tabs.Movement:AddParagraph({
        Title = "Fly Mode",
        Content = "Toggle and adjust fly speed\nControls: WASD to move, Space to go up, Shift to go down\nToggle with T key\nSpeed Hack will be automatically disabled while flying"
    })

    local FlyToggle = Tabs.Movement:AddToggle("FlyToggle", {
        Title = "Fly Mode",
        Description = "Enable/disable fly mode (T to toggle)",
        Default = false
    })

    FlyToggle:OnChanged(function()
        toggleFly(Options.FlyToggle.Value)
    end)

    local FlySlider = Tabs.Movement:AddSlider("FlySlider", {
        Title = "Fly Speed",
        Description = "Adjust the fly speed multiplier",
        Default = 50,
        Min = 20,
        Max = 200,
        Rounding = 1,
        Callback = function(Value)
            FlySpeed = Value
        end
    })
end

-- Player ESP Tab
do
    Tabs.PlayerESP:AddParagraph({
        Title = "Player ESP Settings",
        Content = "Improved ESP with boxes, names, distance and health"
    })

    local ESPToggle = Tabs.PlayerESP:AddToggle("ESPToggle", {
        Title = "Player ESP",
        Description = "Enable/disable player ESP",
        Default = false
    })

    ESPToggle:OnChanged(function()
        ToggleESP(Options.ESPToggle.Value)
    end)

    local BoxToggle = Tabs.PlayerESP:AddToggle("BoxToggle", {
        Title = "Show Boxes",
        Description = "Show boxes around players",
        Default = true
    })

    BoxToggle:OnChanged(function()
        ShowBoxes = Options.BoxToggle.Value
    end)

    local NameToggle = Tabs.PlayerESP:AddToggle("NameToggle", {
        Title = "Show Names",
        Description = "Show player names",
        Default = true
    })

    NameToggle:OnChanged(function()
        ShowNames = Options.NameToggle.Value
    end)

    local DistanceToggle = Tabs.PlayerESP:AddToggle("DistanceToggle", {
        Title = "Show Distance",
        Description = "Show distance to players",
        Default = true
    })

    DistanceToggle:OnChanged(function()
        ShowDistance = Options.DistanceToggle.Value
    end)

    local HealthToggle = Tabs.PlayerESP:AddToggle("HealthToggle", {
        Title = "Show Health",
        Description = "Show player health",
        Default = true
    })

    HealthToggle:OnChanged(function()
        ShowHealth = Options.HealthToggle.Value
    end)

    local TeamToggle = Tabs.PlayerESP:AddToggle("TeamToggle", {
        Title = "Team Check",
        Description = "Show teammates in green, enemies in red",
        Default = true
    })

    TeamToggle:OnChanged(function()
        TeamCheck = Options.TeamToggle.Value
    end)
end

-- Chest ESP Tab
do
    Tabs.ChestESP:AddParagraph({
        Title = "Chest ESP Settings",
        Content = "ESP for legendary and mythic chests"
    })

    local ChestToggle = Tabs.ChestESP:AddToggle("ChestToggle", {
        Title = "Chest ESP",
        Description = "Enable/disable chest ESP",
        Default = false
    })

    ChestToggle:OnChanged(function()
        ToggleChestESP(Options.ChestToggle.Value)
    end)

    local LegendaryToggle = Tabs.ChestESP:AddToggle("LegendaryToggle", {
        Title = "Show Legendary",
        Description = "Show legendary chests",
        Default = true
    })

    LegendaryToggle:OnChanged(function()
        ShowLegendary = Options.LegendaryToggle.Value
    end)

    local MythicToggle = Tabs.ChestESP:AddToggle("MythicToggle", {
        Title = "Show Mythic",
        Description = "Show mythic chests",
        Default = true
    })

    MythicToggle:OnChanged(function()
        ShowMythic = Options.MythicToggle.Value
    end)
end

-- Medal ESP Tab
do
    Tabs.MedalESP:AddParagraph({
        Title = "Medal ESP Settings",
        Content = "ESP for all medal types"
    })

    local MedalToggle = Tabs.MedalESP:AddToggle("MedalToggle", {
        Title = "Medal ESP",
        Description = "Enable/disable medal ESP",
        Default = false
    })

    MedalToggle:OnChanged(function()
        ToggleMedalESP(Options.MedalToggle.Value)
    end)
end

-- Autofarm Tab
do
    Tabs.Autofarm:AddParagraph({
        Title = "Autofarm Settings",
        Content = "Automatically farm NPCs using smooth BodyVelocity movement"
    })

    Tabs.Autofarm:AddButton({
        Title = "Teleport to Fishman Island",
        Description = "Teleport to Fishman Island",
        Callback = function()
            TeleportToPosition(CFrame.new(8003.553, -2150, -17056.971))
        end
    })

    Tabs.Autofarm:AddButton({
        Title = "Teleport to Sword",
        Description = "Teleport to Sword location",
        Callback = function()
            TeleportToPosition(CFrame.new(5426.218, 20, -4918.854))
        end
    })

    local AutoFarmToggle = Tabs.Autofarm:AddToggle("AutoFarmToggle", {
        Title = "Auto Farm",
        Description = "Automatically farm Fishman Karate Users with smooth movement",
        Default = false
    })

    AutoFarmToggle:OnChanged(function()
        ToggleAutoFarm(Options.AutoFarmToggle.Value)
    end)

    -- Add speed slider for autofarm
    local FarmSpeedSlider = Tabs.Autofarm:AddSlider("FarmSpeedSlider", {
        Title = "Farm Movement Speed",
        Description = "Adjust the movement speed when farming",
        Default = 50,
        Min = 20,
        Max = 200,
        Rounding = 1,
        Callback = function(Value)
            TweenFarmSpeed = Value
        end
    })
end

-- Trolling Tab
do
    Tabs.Trolling:AddParagraph({
        Title = "Trolling Features",
        Content = "Various trolling features"
    })

    Tabs.Trolling:AddButton({
        Title = "Fruit Rain",
        Description = "Start fruit rain",
        Callback = StartFruitRain
    })
end

-- Addons
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab(1)

Fluent:Notify({
    Title = "Fluent",
    Content = "The script has been loaded.",
    Duration = 8
})

SaveManager:LoadAutoloadConfig()
